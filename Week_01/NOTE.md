学习笔记
1、用 add first 或 add last 这套新的 API 改写 Deque 的代码
    Deque<String> deque = new LinkedList<>();
    deque.addLast("a");
    deque.addLast("b");
    deque.addLast("c");
    deque.addLast("d");
    System.out.println(deque);
    String peek = deque.peek();
    System.out.println(peek);
    System.out.println(deque);
    while (deque.size() > 0){
        System.out.println(deque.pollLast());
    }
    System.out.println(deque);
    
2、分析 Queue 和 Priority Queue 的源码
Queue 满足先进新出，类似真实世界的排队，特殊的队列有双端队列、优先级队列（优先级高的往前排，类似VIP客户）
java中的PriorityQueue是一种无界的，线程不安全的队列；PriorityQueue是一种通过数组实现的，并拥有优先级的队列；
PriorityQueue存储的元素要求必须是可比较的对象， 如果不是就必须明确指定比较器







算法练习总结
本周的算法题主要集中在数组，链表，以及栈和队列相关的题目，下面总结一下这周训练过程中获得的解题技巧，

技巧1：定义多个指针协助解题
141-环形链表，206-反转链表等题目实际上都可以通过引入多个指针，然后通过指针的移动控制元素的变化， 来达到解题目的，还有一些应用快慢指针的思路，个人觉得遇到链表的一些题目，大多都需要定义多个临时的 指针变量，来辅助各个节点在循环中的变化。

技巧2：干想不如画图
基本上每个算法题目，我都会在演算纸上面把每次循环后元素的变化画在纸上，来辅助自己理清楚思路，即使 有些题目并不是自己想出来的解法，也会把别人的解法理解了之后再自己思考一遍，这样基本上图画清楚之后， 写代码也就是水到渠成的事情了，尤其是链表相关的题目，由于代码理解起来比较晦涩，并不直观，所以必须 要把指针的变化画在纸上。

技巧3：找到子问题，巧用递归
其实链表的很多题目都可以通过递归的方式来解决，而递归的重点就在于如何找到子问题，比如爬楼梯问题中， 递归的方法就在于只关心最后1级台阶和最后两级台阶的走法，来假设子问题已经解决，那么只解决最后一步 就可以了，同理也适用于反转链表，假设head节点之后的所有节点都已经被正确反转了，那么就只需要考虑 如何反转head节点和已经反转之后的那个返回值节点之间如何反转就可以了。

技巧4：理解题意，关注边界
我认为很多算法题目其实解法并不难，难的在于深入的利用题目所给出的限定条件，这时就需要深刻理解题目， 就像老师课程中讲的，面试时要和面试官反复确认题目要求，确保理解题意；而另外一个重点就是关注各种边界 条件的处理，因为往往逻辑虽然是正确的，但也会由于边界条件没有仔细考虑，而导致某些corner case无法 通过。

注意：
好记性不如烂笔头， 因此请尝试
1）给每一道自己写过，看过的题目写一篇解题报告，
2）对相关一类题型的总结报告。
https://github.com/kevinnerd/algorithm008-class01/tree/master/Week_01