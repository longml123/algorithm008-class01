
算法练习总结
本周的算法题主要集中在数组，链表，以及栈和队列相关的题目，下面总结一下这周训练过程中获得的解题技巧，

技巧1：定义多个指针协助解题
141-环形链表，206-反转链表等题目实际上都可以通过引入多个指针，然后通过指针的移动控制元素的变化， 来达到解题目的，还有一些应用快慢指针的思路，个人觉得遇到链表的一些题目，大多都需要定义多个临时的 指针变量，来辅助各个节点在循环中的变化。

技巧2：干想不如画图
基本上每个算法题目，我都会在演算纸上面把每次循环后元素的变化画在纸上，来辅助自己理清楚思路，即使 有些题目并不是自己想出来的解法，也会把别人的解法理解了之后再自己思考一遍，这样基本上图画清楚之后， 写代码也就是水到渠成的事情了，尤其是链表相关的题目，由于代码理解起来比较晦涩，并不直观，所以必须 要把指针的变化画在纸上。

技巧3：找到子问题，巧用递归
其实链表的很多题目都可以通过递归的方式来解决，而递归的重点就在于如何找到子问题，比如爬楼梯问题中， 递归的方法就在于只关心最后1级台阶和最后两级台阶的走法，来假设子问题已经解决，那么只解决最后一步 就可以了，同理也适用于反转链表，假设head节点之后的所有节点都已经被正确反转了，那么就只需要考虑 如何反转head节点和已经反转之后的那个返回值节点之间如何反转就可以了。

技巧4：理解题意，关注边界
我认为很多算法题目其实解法并不难，难的在于深入的利用题目所给出的限定条件，这时就需要深刻理解题目， 就像老师课程中讲的，面试时要和面试官反复确认题目要求，确保理解题意；而另外一个重点就是关注各种边界 条件的处理，因为往往逻辑虽然是正确的，但也会由于边界条件没有仔细考虑，而导致某些corner case无法 通过。

以上都是借鉴笔记：https://github.com/kevinnerd/algorithm008-class01/blob/master/Week_01/NOTE.md

课后分析题
1、用 add first 或 add last 这套新的 API 改写 Deque 的代码。
    Deque<String> deque = new LinkedList<>();
    deque.addLast("a");
    deque.addLast("b");
    deque.addLast("c");
    deque.addLast("d");
    System.out.println(deque);
    String peek = deque.peek();
    System.out.println(peek);
    System.out.println(deque);
    while (deque.size() > 0){
        System.out.println(deque.pollLast());
    }
    System.out.println(deque);
    
2、分析 Queue 和 Priority Queue 的源码。
Queue 满足先进新出，类似真实世界的排队，特殊的队列有双端队列、优先级队列（优先级高的往前排，类似VIP客户）
java中的PriorityQueue是一种无界的，线程不安全的队列；PriorityQueue是一种通过数组实现的，并拥有优先级的队列；
PriorityQueue存储的元素要求必须是可比较的对象， 如果不是就必须明确指定比较器

注意：
好记性不如烂笔头， 因此请尝试
1）给每一道自己写过，看过的题目写一篇解题报告，
2）对相关一类题型的总结报告。

写了这么多年代码，你真的了解SOLID吗？
总的来说，单独应用SOLID的某一个原则并不能让收益最大化。应该把它作为一个整体来理解和应用，
从而更好地指导你的软件设计。单一职责是所有设计原则的基础，开闭原则是设计的终极目标。
里氏替换原则强调的是子类替换父类后程序运行时的正确性，它用来帮助实现开闭原则。
而接口隔离原则用来帮助实现里氏替换原则，同时它也体现了单一职责。
依赖倒置原则是过程式编程与OO编程的分水岭，同时它也被用来指导接口隔离原则。

https://insights.thoughtworks.cn/do-you-really-know-solid/